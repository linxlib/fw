package fw

import (
	"errors"
	"fmt"
	"github.com/fasthttp/router"
	"github.com/gookit/color"
	"github.com/linxlib/astp"
	"github.com/linxlib/astp/constants"
	types2 "github.com/linxlib/astp/types"
	"github.com/linxlib/config"
	"github.com/linxlib/fw/binding"
	"github.com/linxlib/fw/inject"
	"github.com/linxlib/fw/internal"
	"github.com/linxlib/fw/types"
	"github.com/pterm/pterm"
	"github.com/sirupsen/logrus"
	"github.com/valyala/fasthttp"
	"gopkg.in/natefinch/lumberjack.v2"
	"log/slog"
	"os"
	"reflect"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
)

const Version = "v1.0.0@beta"

type HookHandler interface {
	HandleServerInfo(si []string)
	HandleStructs(ctl *types2.Struct)

	Print(slot string)
}

type ServerOption struct {
	IntranetIP            string
	Dev                   bool         `yaml:"dev" default:"true"`
	Debug                 bool         `yaml:"debug" default:"true"`
	NoColor               bool         `yaml:"nocolor" default:"false"`
	BasePath              string       `yaml:"basePath" default:"/"`
	Listen                string       `yaml:"listen" default:"127.0.0.1"` //监听地址
	Title                 string       `yaml:"title" default:"fw api"`
	Name                  string       `yaml:"name" default:"fw"` //server_token
	ShowRequestTimeHeader bool         `yaml:"showRequestTimeHeader,omitempty" default:"true"`
	RequestTimeHeader     string       `yaml:"requestTimeHeader,omitempty" default:"Request-Time"`
	Port                  int          `yaml:"port" default:"2024"`
	AstFile               string       `yaml:"astFile" default:"gen.gz"` //ast json file generated by github.com/linxlib/astp. default is gen.json
	Logger                LoggerOption `yaml:"logger"`
}
type LoggerOption struct {
	LoggerLevel       int    `yaml:"loggerLevel" default:"4"` //0-6 0: Panic 6: Trace
	SeparateLevelFile bool   `yaml:"separateLevelFile" default:"false"`
	LogDir            string `yaml:"logDir" default:"log"`
	RotateFile        bool   `yaml:"rotate" default:"true"`
	MaxSize           int    `yaml:"maxSize" default:"5"`
	MaxAge            int    `yaml:"maxAge" default:"28"`
	MaxBackups        int    `yaml:"maxBackups" default:"3"`
	Compress          bool   `yaml:"compress" default:"false"`
	LocalTime         bool   `yaml:"localTime" default:"true"`
}

func New(key ...string) *Server {
	s := &Server{
		Injector:           inject.New(),
		router:             router.New(),
		server:             &fasthttp.Server{},
		option:             new(ServerOption),
		parser:             &astp.Parser{Project: &types2.Project{}},
		middleware:         NewMiddlewareContainer(),
		routerTreeForPrint: make(map[string][][2]string),
		beginTime:          time.Now(),
		plugins:            make([]IPlugin, 0),
	}
	s.conf = config.New(&config.Option{
		AutoReload:         true,
		Silent:             true,
		ENVPrefix:          "FW",
		Files:              []string{"config/config.yaml"},
		AutoReloadInterval: time.Second * 1,
		AutoReloadCallback: func(key string, config interface{}) {
			fmt.Println("key=", key, "config=", config)
		},
	})
	s.option.IntranetIP = getIntranetIP()
	configKey := ""
	if len(key) > 0 {
		configKey = key[0]
	}
	err := s.conf.LoadWithKey(configKey, s.option)
	if err != nil {
		panic(err)
	}
	//pterm.DefaultHeader.WithBackgroundStyle(pterm.NewStyle(pterm.BgBlack)).WithFullWidth().Println("FW for golang developers")

	s.configLogger()

	s.Map(s.option)
	s.Map(s.conf)

	s.Map(s)
	if !internal.FileIsExist(s.option.AstFile) {
		if s.option.Dev {
			parser := astp.Parser{}
			parser.Parse()
			_ = parser.Write(s.option.AstFile)
		} else {
			panic(fmt.Sprintf("%s not found, please generate it first!", s.option.AstFile))
		}
	}

	s.parser.Read(s.option.AstFile)
	return s
}

type Server struct {
	inject.Injector
	server             *fasthttp.Server
	router             *router.Router
	option             *ServerOption
	conf               *config.Config
	parser             *astp.Parser
	middleware         *MiddlewareContainer
	logger             *logrus.Logger
	once               sync.Once
	midGlobals         []IMiddlewareCtl
	routerTreeForPrint map[string][][2]string
	beginTime          time.Time
	plugins            []IPlugin
}

type IPlugin interface {
	InitPlugin(s *Server)
	HandleServerInfo(si []*types2.Comment)
	HandleStructs(ctl *types2.Struct)
	Print(slot string)
}

func (s *Server) AddPlugin(plugin IPlugin) {
	s.plugins = append(s.plugins, plugin)
}

func (s *Server) configLogger() {
	var l types.ILogger = new(types.Logger)
	s.Map(l)

	logger := logrus.New()
	logger.SetOutput(os.Stdout)
	logger.SetFormatter(Console())
	logger.SetLevel(logrus.InfoLevel)
	logger.SetReportCaller(true)

	logger.SetLevel(logrus.Level(s.option.Logger.LoggerLevel))
	dir := s.option.Logger.LogDir

	if !s.option.Logger.RotateFile {
		if s.option.Logger.SeparateLevelFile {

			pathMap := PathMap{
				logrus.InfoLevel:  dir + "/info.log",
				logrus.ErrorLevel: dir + "/error.log",
				logrus.DebugLevel: dir + "/debug.log",
			}
			logger.AddHook(NewFileHook(pathMap, File()))
		} else {
			logger.AddHook(NewFileHook(dir+"/fw.log", File()))
		}
	} else {
		if s.option.Logger.SeparateLevelFile {
			writerMap := WriterMap{
				logrus.InfoLevel: &lumberjack.Logger{
					Filename:   dir + "/info.log",
					Compress:   s.option.Logger.Compress,
					MaxSize:    s.option.Logger.MaxSize,
					MaxAge:     s.option.Logger.MaxAge,
					MaxBackups: s.option.Logger.MaxBackups,
					LocalTime:  s.option.Logger.LocalTime,
				},
				logrus.ErrorLevel: &lumberjack.Logger{
					Filename:   dir + "/error.log",
					Compress:   s.option.Logger.Compress,
					MaxSize:    s.option.Logger.MaxSize,
					MaxAge:     s.option.Logger.MaxAge,
					MaxBackups: s.option.Logger.MaxBackups,
					LocalTime:  s.option.Logger.LocalTime,
				},

				logrus.DebugLevel: &lumberjack.Logger{
					Filename:   dir + "/debug.log",
					Compress:   s.option.Logger.Compress,
					MaxSize:    s.option.Logger.MaxSize,
					MaxAge:     s.option.Logger.MaxAge,
					MaxBackups: s.option.Logger.MaxBackups,
					LocalTime:  s.option.Logger.LocalTime,
				},
			}
			logger.AddHook(NewFileHook(writerMap, File()))
		} else {

			logger.AddHook(NewFileHook(&lumberjack.Logger{
				Filename:   dir + "/fw.log",
				Compress:   s.option.Logger.Compress,
				MaxSize:    s.option.Logger.MaxSize,
				MaxAge:     s.option.Logger.MaxAge,
				MaxBackups: s.option.Logger.MaxBackups,
				LocalTime:  s.option.Logger.LocalTime,
			}, File()))
		}

	}

	s.logger = logger
	s.Map(s.logger)
}

type HandlerFunc = func(*Context)

// wrap the HandlerFunc to fasthttp.RequestHandler
// just create *Context
func (s *Server) wrap(h HandlerFunc) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		start := time.Now()
		c := newContext(ctx, s)
		h(c)
		if s.option.ShowRequestTimeHeader {
			c.ctx.Response.Header.Set(s.option.RequestTimeHeader, time.Since(start).String())
		}
	}
}

func (s *Server) RegisterRoutes(controller ...any) {
	for _, a := range controller {
		s.RegisterRoute(a)
	}
}

const controllerAttr = "Controller"
const controllerRoute = "Route"

func (s *Server) RegisterRoute(controller any) {

	if v, ok := controller.(IController); ok {
		v.Init(s)
	}
	if v, ok := controller.(IControllerConfig); ok {
		v.InitConfig(s.conf)
	}
	//defer func() {
	//	if err := recover(); err != nil {
	//		s.logger.Error(err)
	//	}
	//}()
	//假定astp已经解析好了整个项目，并通过某种方式还原了Parser内部的值
	// 这里需要通过传入的controller指针 并通过反射方式获取到 controller method param result各种的反射值，并填充到已有的Parser里
	// 这里的指针 通过代码生成的方式
	// 1. 从Parser中获取controller的包路径
	// 2. 生成代码将controller new出来 传到这里来
	//refTyp := reflect.TypeOf(controller)
	refVal := reflect.ValueOf(controller)
	typ := reflect.Indirect(refVal).Type()

	// 处理全局

	s.once.Do(func() {
		for _, plugin := range s.plugins {
			plugin.InitPlugin(s)
		}
		s.midGlobals = make([]IMiddlewareCtl, 0)
		routeItems := make([]*RouteItem, 0)
		s.middleware.GetGlobal(func(mid IMiddlewareGlobal) bool {
			ctx := newMiddlewareContext(mid.Name(), "", SlotGlobal, "", nil)
			r := mid.Router(ctx)
			if r != nil {
				routeItems = append(routeItems, r...)
			}
			s.midGlobals = append(s.midGlobals, mid)
			return false
		})
		for _, item := range routeItems {
			if item.Path != "" && item.Method != "" {
				err := s.registerRoute(item.Method, joinRoute(s.option.BasePath, item.Path, item.OverrideBasePath), item.H)
				if err != nil {
					panic(err)
				}
				if !item.IsHide {
					s.addRouteTable("Global", item.Method, joinRoute(s.option.BasePath, item.Path, item.OverrideBasePath), item.Middleware.Name()+".H", "@"+item.Middleware.Name())
				}
			}
		}

	})

	// 遍历代码中所有的 @Controller 标记的结构，按照控制器对待
	s.parser.VisitStructByName(typ.Name(), func(element *types2.Struct) bool {
		return element.HasAttr(constants.AT_CONTROLLER) || strings.HasSuffix(element.Name, controllerAttr)
	}, func(ctl *types2.Struct) {

		// 第一层路由 【配置文件】
		base := s.option.BasePath
		if base == "" {
			base = "/"
		}
		// 第二层路由 @Route 标记

		if r := ctl.GetAttrValue(constants.AT_ROUTE); r != "" {
			base = joinRoute(base, r)
		}
		ctl.SetRValue(refVal)
		ctl.SetValue(refVal.Interface())
		ctl.SetRType(typ)
		//处理控制器
		middlewareCtls := make([]IMiddlewareCtl, 0)
		routeItems := make([]*RouteItem, 0)

		attrs1 := ctl.GetCustomAttrs()
		for _, attr := range attrs1 {
			if mid, ok := s.middleware.GetByAttributeCtl(strings.ToUpper(attr.CustomAttr)); ok {
				ctx := newMiddlewareContext(ctl.Name, "", SlotController, attr.AttrValue, nil)
				ctx.SetRValue(ctl.GetRValue())
				r := mid.Router(ctx)
				if r != nil {
					routeItems = append(routeItems, r...)
				}
				middlewareCtls = append(middlewareCtls, mid)

			}
		}

		for _, item := range routeItems {
			if item.Path != "" && item.Method != "" {
				err := s.registerRoute(item.Method, joinRoute(base, item.Path, item.OverrideBasePath), item.H)
				if err != nil {
					continue
				}
				if !item.IsHide {
					s.addRouteTable(ctl.Name, item.Method, joinRoute(base, item.Path, item.OverrideBasePath), ctl.Name, "@"+item.Middleware.Attribute())
				}
			}
		}
		for _, plugin := range s.plugins {
			plugin.HandleStructs(ctl)
		}
		//处理控制器方法
		ctl.VisitMethods(func(element *types2.Function) bool {
			return !element.Private && element.HasAttrs()
		}, func(method *types2.Function) {
			vm := refVal.MethodByName(method.Name)
			vmt := reflect.TypeOf(vm.Interface())
			// 此处将方法参数得反射类型（reflect.Type）暂存
			method.VisitParams(func(param *types2.Param) {
				param.SetRType(vmt.In(param.Index))
			})
			// 方法的reflect.Value暂存，用于传递给中间件
			method.SetRValue(vm)
			method.SetValue(vm.Interface())
			var hms = make([]string, 0)
			var rps = make([]string, 0)
			var toIgnore string
			for _, attr := range method.GetAttrs() {
				if attr.AttrType == constants.AT_POST ||
					attr.AttrType == constants.AT_PUT ||
					attr.AttrType == constants.AT_DELETE ||
					attr.AttrType == constants.AT_OPTIONS ||
					attr.AttrType == constants.AT_HEAD ||
					attr.AttrType == constants.AT_PATCH ||
					attr.AttrType == constants.AT_GET {
					hms = append(hms, constants.AttrNames[attr.AttrType])
					rps = append(rps, attr.AttrValue)
				} else if attr.AttrType == constants.AT_IGNORE && attr.AttrValue != "" {
					//处理忽略
					toIgnore = strings.ToUpper(attr.AttrValue)
				}
			}
			// 先处理方法上标记的中间件
			attrs, next := s.handle(ctl, method)
			// 然后处理controller上的中间件
			for _, mid := range middlewareCtls {

				ctx := newMiddlewareContext(ctl.Name, method.Name, SlotMethod, "", next)
				ctx.SetRValue(ctl.GetRValue())
				// 如果方法上打了 @Ignore Auth 则需要忽略 Auth这个代表 AuthMiddleware 的中间件
				//TODO: 是否需要处理 @Ignore 多个的情况？
				if toIgnore == strings.ToUpper(mid.Attribute()) {
					ctx.Ignored = true
				} else {
					attrs = append(attrs, mid.Attribute())
				}
				next = mid.Execute(ctx)
			}
			// 这里全局的中间件 仅针对于方法，不会对Controller做出改变
			for _, global := range s.midGlobals {
				ctx := newMiddlewareContext(global.Name(), "", SlotGlobal, "", next)
				next = global.Execute(ctx)
			}

			sig := strings.Builder{}
			for i, attr := range attrs {
				if i != 0 {
					sig.WriteRune(',')
				}
				sig.WriteString("@")
				sig.WriteString(attr)
			}
			if len(hms) <= 0 {
				a, b, ok := handleDefaultMethodRoute(method.Name, !method.Private)
				if ok {
					s.registerRoute(a, joinRoute(base, b), next)
					receiver := method.Receiver
					controllerName := receiver.Type
					route := joinRoute(base, b)
					//if method.FromParent {
					//	if sig.Len() != 0 {
					//		sig.WriteRune(',')
					//	}
					//
					//	sig.WriteString("@inherit")
					//}
					s.addRouteTable(controllerName, a, route, method.Name, sig.String())
				}

			} else {
				for i, hm := range hms {
					err := s.registerRoute(strings.ToUpper(hm), joinRoute(base, rps[i]), next)
					if err != nil {
						continue
					}
					receiver := method.Receiver
					controllerName := receiver.Type
					route := joinRoute(base, rps[i])
					//if method.FromParent {
					//	if sig.Len() != 0 {
					//		sig.WriteRune(',')
					//	}
					//
					//	sig.WriteString("@inherit")
					//}
					s.addRouteTable(controllerName, strings.ToUpper(hm), route, method.Name, sig.String())
				}
			}

		})

	})
}

func (s *Server) registerRoute(method string, path string, f HandlerFunc) error {
	call1 := s.wrap(f)
	switch method {
	case "POST":
		s.router.POST(path, call1)
	case "GET":
		s.router.GET(path, call1)
	case "DELETE":
		s.router.DELETE(path, call1)
	case "PATCH":
		s.router.PATCH(path, call1)
	case "PUT":
		s.router.PUT(path, call1)
	case "OPTIONS":
		s.router.OPTIONS(path, call1)
	case "HEAD":
		s.router.HEAD(path, call1)
	case "ANY", "WS":
		s.router.ANY(path, call1)
	default:
		return fmt.Errorf("http method:[%v -> %s] not supported", method, path)
	}

	return nil
}

func handleDefaultMethodRoute(name string, isPublic bool) (method, path string, ok bool) {
	if !isPublic {
		return "", "", false
	}
	// 1. 提取HTTP方法（GET, POST, PUT等），忽略大小写
	httpMethods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "ANY", "WS"}
	methodName := name
	for _, m := range httpMethods {
		if strings.HasPrefix(strings.ToUpper(methodName), m) {
			method = m
			methodName = methodName[len(m):] // 去掉方法前缀
			break
		}
	}
	if method == "" {
		return "", "", false
	}
	// 2. 将剩余部分转为snake_case
	// 使用正则表达式查找大写字母并将其转换为小写字母前面加下划线
	re := regexp.MustCompile("([a-z0-9])([A-Z])")
	snakeCase := re.ReplaceAllString(methodName, `${1}_${2}`)
	snakeCase = strings.ToLower(snakeCase) // 转为小写
	return methodName, "/" + snakeCase, true
}

func (s *Server) bind(c *Context, handler *types2.Function) error {
	// 准备调用方法需要的参数值
	params := handler.Param
	for _, param := range params {
		// 跳过 Context 内置类型
		if param.GetRType().AssignableTo(reflect.TypeOf(c)) {
			c.Map(c)
			continue
		}
		// 剩下的参数需要检查是否是参数(是否可以被bind)
		canBeBind := false

		if param.Struct != nil && param.Struct.HasParamAttr() {
			canBeBind = true
		}

		if (c.Method() == "GET" || c.Method() == "HEAD") &&
			(param.Struct.HasAttr(constants.AT_BODY) || param.Struct.HasAttr(constants.AT_JSON) ||
				param.Struct.HasAttr(constants.AT_XML) || param.Struct.HasAttr(constants.AT_FORM) ||
				param.Struct.HasAttr(constants.AT_MULTIPART) || param.Struct.HasAttr(constants.AT_PLAIN)) {
			//get方法不能有body 类似不合规的参数, 进行跳过
			return errors.New("http get/head method can not have body")
		}

		if !canBeBind {
			continue
		}
		//TODO: 是否要兼容 非指针方式声明的参数
		paramV := reflect.New(param.GetRType().Elem())
		// 对方法参数进行数据映射和校验
		binder := binding.GetByAttr(param.Struct.GetAttr())
		if binding.IsBodyBinder(binder) {
			if c.Method() == "POST" || c.Method() == "PUT" || c.Method() == "PUT" || c.Method() == "PATCH" || c.Method() == "DELETE" {
				switch c.GetHeader("Content-Type") {
				case "application/json":
					binder = binding.JSON
				case "application/xml":
					binder = binding.XML
				case "application/x-www-form-urlencoded":
					binder = binding.Form
				case "multipart/form-data":
					binder = binding.FormMultipart
				case "text/plain":
					binder = binding.Plain

				}
			}
		}

		if err := binder.Bind(c.GetFastContext(), paramV.Interface()); err != nil {
			return err
		}
		if paramV.CanInterface() {
			c.Map(paramV.Interface())
		} else {
			c.Map(paramV.Elem().Interface())
		}

	}

	return nil
}
func callers(skip int) {
	pcs := make([]uintptr, 1024)
	runtime.Callers(skip+2, pcs)
	frames := runtime.CallersFrames(pcs)
	for {
		frame, more := frames.Next()
		fmt.Println(frame.File+":"+strconv.Itoa(frame.Line), frame.Function)
		if !more {
			break
		}
	}
}
func (s *Server) wrapM(handler *types2.Function) HandlerFunc {
	return func(context *Context) {
		defer func() {
			if err := recover(); err != nil {

				switch err1 := err.(type) {
				case error:
					slog.Error(err1.Error())
					callers(2)
					//panic(err1)
					//context.Error(err1.(error))
				case string:
					if err != "fw" {
						panic(err1)
					}
				}

			}
		}()
		var err error
		// binding params
		err = s.bind(context, handler)
		//if err != nil {
		//	panic(err)
		//}
		// call method

		values, err := context.inj.Invoke(handler.GetValue())
		if err != nil {
			panic(err)
		}
		last := len(values) - 1
		if last == -1 { // if there is no return value, just skip.
			if !context.hasReturn {
				context.SendStatus(200)
			}
			return
		}

		if err := values[last]; !err.IsZero() {
			// if the last return value is error, parse it and write error info into response body
			if e, ok := err.Interface().(error); ok {
				context.ErrorExit(e)
			} else { // If there is no error return value, the return value will be treated as a normal return.
				// and only one return value will be written into response body
				if !context.hasReturn {
					context.JSON(200, values[0].Interface())
				}
			}
		} else {
			// method returns error, just ignore others.
			if !context.hasReturn {
				if values[0].IsNil() {
					context.Status(200)
				} else {
					context.JSON(200, values[0].Interface())
				}

			}
			//context.Error(err.Interface().(error))
		}
	}
}

func (s *Server) handle(ctl *types2.Struct, handler *types2.Function) ([]string, HandlerFunc) {
	//先把实际的方法wrap成HandlerFunc
	next := s.wrapM(handler)
	// 先处理method上的中间件
	attrs := handler.GetCustomAttrs()
	var attrs1 []string
	for _, attr := range attrs {
		if mid, ok := s.middleware.GetByAttributeMethod(strings.ToUpper(attr.CustomAttr)); ok {
			attrs1 = append(attrs1, mid.Attribute())

			ctx := newMiddlewareContext(ctl.Name, handler.Name, SlotMethod, attr.AttrValue, next)
			ctx.SetRValue(ctl.GetRValue())
			next = mid.Execute(ctx)
		}
	}
	return attrs1, next
}

func (s *Server) addRouteTable(controllerName, method, routePath, methodName, signature string) {
	var fcolor1 = func(method string) string {
		switch method {
		case "GET":
			return color.Blue.Sprint(method)
		case "POST":
			return color.Cyan.Sprint(method)
		case "PUT":
			return color.Yellow.Sprint(method)
		case "DELETE":
			return color.Red.Sprint(method)
		case "PATCH":
			return color.Green.Sprint(method)
		case "HEAD":
			return color.Magenta.Sprint(method)
		case "OPTIONS":
			return color.White.Sprint(method)
		default:
			return color.Normal.Sprint(method)
		}
	}
	const itemFmt = "%-16s %-30s%-30s"
	controllerName = color.Magenta.Sprint(controllerName)
	if v, ok := s.routerTreeForPrint[controllerName]; ok {
		var temp [2]string
		temp[0] = color.HiYellow.Sprint(signature)
		if methodName == "" {
			temp[1] = fmt.Sprintf(itemFmt, fcolor1(method), routePath, color.HiGreen.Sprint(""))
		} else {
			temp[1] = fmt.Sprintf(itemFmt, fcolor1(method), routePath, "-> "+color.HiGreen.Sprint(methodName))
		}

		v = append(v, temp)
		s.routerTreeForPrint[controllerName] = v
	} else {
		s.routerTreeForPrint[controllerName] = make([][2]string, 0)
		var temp [2]string
		temp[0] = color.HiYellow.Sprint(signature)
		if methodName == "" {
			temp[1] = fmt.Sprintf(itemFmt, fcolor1(method), routePath, color.HiGreen.Sprint(""))
		} else {
			temp[1] = fmt.Sprintf(itemFmt, fcolor1(method), routePath, "-> "+color.HiGreen.Sprint(methodName))
		}
		s.routerTreeForPrint[controllerName] = append(s.routerTreeForPrint[controllerName], temp)
	}
}

func (s *Server) printRoute() {
	var node = pterm.TreeNode{
		Text: "FW Server",
	}

	for s2, i := range s.routerTreeForPrint {
		no := pterm.TreeNode{
			Text: s2,
		}
		for _, i3 := range i {
			no.Children = append(no.Children,
				pterm.TreeNode{
					Text: i3[1] + " " + i3[0],
				})
		}
		node.Children = append(node.Children, no)
	}
	_ = pterm.DefaultTree.WithRoot(node).Render()
}

func (s *Server) printInfo() {
	style := pterm.NewStyle(pterm.FgLightGreen, pterm.Bold)
	style1 := pterm.NewStyle(pterm.FgLightGreen)
	style2 := pterm.NewStyle(pterm.FgDarkGray)
	style3 := pterm.NewStyle(pterm.FgLightWhite, pterm.Bold)
	style4 := pterm.NewStyle(pterm.FgWhite)
	style.Print("FW ")
	style1.Print(Version + " ")
	style2.Print("ready in ")
	style3.Println(time.Now().Sub(s.beginTime).String())

	//color.Printf("%s %s %s\n", color.HiGreen.Sprintf("FW %s", Version), color.Gray.Sprint("ready in"), color.HiWhite.Sprint("568ms"))
	style.Print("  ➜ ")
	style3.Printf("%10s", "Local: ")
	style4.Printf("http://%s:%d%s\n", s.option.Listen, s.option.Port, s.option.BasePath)
	if s.CanAccessByLan() {
		style.Print("  ➜ ")
		style3.Printf("%10s", "Network: ")
		style4.Printf("http://%s:%d%s\n", s.option.IntranetIP, s.option.Port, s.option.BasePath)
	}
	for _, plugin := range s.plugins {
		plugin.Print(AfterListen)
	}
	if s.option.Dev {
		if runtime.GOOS == "darwin" {
			internal.Note("press ⌘+C to exit...")
		} else {
			internal.Note("press CTRL+C to exit...")
		}
	}
}
func (s *Server) CanAccessByLan() bool {
	if strings.EqualFold(s.option.IntranetIP, s.option.Listen) || strings.EqualFold(s.option.Listen, "0.0.0.0") {
		return true
	}
	return false
}

func (s *Server) Run() chan bool {
	return s.start()
}
func (s *Server) start() chan bool {

	for _, plugin := range s.plugins {
		for _, file := range s.parser.FileMap {
			if !file.IsMainPackage() {
				continue
			}
			plugin.HandleServerInfo(file.Comment)
		}
	}

	s.printRoute()

	s.server.Handler = s.router.Handler
	s.server.StreamRequestBody = true
	s.server.Name = s.option.Name

	done := make(chan bool)
	go func() {
		err := s.server.ListenAndServe(fmt.Sprintf("%s:%d", s.option.Listen, s.option.Port))
		if err != nil {
			internal.Errorf("Failed to start server: %v", err)
			done <- true
			return
		}
	}()

	s.printInfo()
	return done
}
func (s *Server) ListenAddr() string {
	return s.option.Listen
}
func (s *Server) Port() int {
	return s.option.Port
}
func (s *Server) Schema() string {
	return "http"
}
func (s *Server) BasePath() string {
	return strings.TrimSuffix(s.option.BasePath, "/")
}

func (s *Server) Start() {
	done := s.start()
	for {
		select {
		case <-done:
			return
		}
	}
}

const (
	AfterListen = "afterListen"
)

// Use register middleware to server.
// you can only use the @'Attribute' after register a middleware
func (s *Server) Use(middleware ...IMiddleware) {
	if len(middleware) <= 0 {
		return
	}
	for _, iMiddleware := range middleware {
		iMiddleware.setConfig(s.conf)
		iMiddleware.setProvider(s)
		_ = s.Apply(iMiddleware)
		iMiddleware.DoInitOnce()
		s.middleware.Reg(iMiddleware)
	}

}

func (s *Server) UseMapper(mapper ...ServiceMapper) {
	if len(mapper) <= 0 {
		return
	}
	for _, serviceMapper := range mapper {
		result, err := serviceMapper.Init(s.conf)
		if err != nil {
			panic(err)
		}
		s.Map(result)
	}

}

func (s *Server) UseService(service ...IService) {
	if len(service) <= 0 {
		return
	}
	for _, iService := range service {
		iService.Init(s)
		s.Map(iService)
	}

}

func (s *Server) UseServiceWithConfig(service ...IServiceConfig) {
	if len(service) <= 0 {
		return
	}
	for _, serviceConfig := range service {
		serviceConfig.InitConfig(s.conf)
		s.Map(serviceConfig)
	}

}
